package ru.easydonate.exploitfix.patcher;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.core.Appender;
import org.apache.logging.log4j.core.Logger;
import org.apache.logging.log4j.core.filter.AbstractFilterable;
import org.bukkit.plugin.Plugin;

import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public final class LoggerPatcher {

    private final Plugin plugin;
    private final LoggerFilter loggerFilter;

    public LoggerPatcher(Plugin plugin, Pattern detectorPattern) {
        this.plugin = plugin;
        this.loggerFilter = new LoggerFilter(detectorPattern);
    }

    public boolean patch() {
        try {
            List<String> processedAppenders = patchAvailableLoggers();
            plugin.getLogger().info("Logger filter has been applied for appenders: " + String.join(", ", processedAppenders));
            return true;
        } catch (Throwable throwable) {
            plugin.getLogger().severe("Couldn't add filters to some logger(s).");
            plugin.getLogger().severe("Logger version is probably incompatible!");
            plugin.getLogger().severe("Details: " + throwable.getMessage());
            return false;
        }
    }

    private List<String> patchAvailableLoggers() {
        Map<String, Appender> appenders = ((Logger) LogManager.getRootLogger()).getAppenders();

        return appenders.values().stream()
                .filter((appender -> appender instanceof AbstractFilterable))
                .peek(appender -> ((AbstractFilterable) appender).addFilter(loggerFilter))
                .map(Appender::getName)
                .collect(Collectors.toList());
    }

}
